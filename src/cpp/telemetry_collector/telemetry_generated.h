// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_TELEMETRY_TELEMETRY_H_
#define FLATBUFFERS_GENERATED_TELEMETRY_TELEMETRY_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 23 &&
              FLATBUFFERS_VERSION_MINOR == 5 &&
              FLATBUFFERS_VERSION_REVISION == 26,
             "Non-compatible flatbuffers version included");

namespace Telemetry {

struct HandEquity;
struct HandEquityBuilder;

struct TelemetryPacket;
struct TelemetryPacketBuilder;

struct HandEquity FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef HandEquityBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_HAND_NAME = 4,
    VT_EQUITY = 6,
    VT_WINS = 8,
    VT_TIES = 10,
    VT_LOSSES = 12,
    VT_SIMULATIONS = 14,
    VT_WIN_METHOD_MATRIX = 16
  };
  const ::flatbuffers::String *hand_name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_HAND_NAME);
  }
  double equity() const {
    return GetField<double>(VT_EQUITY, 0.0);
  }
  uint32_t wins() const {
    return GetField<uint32_t>(VT_WINS, 0);
  }
  uint32_t ties() const {
    return GetField<uint32_t>(VT_TIES, 0);
  }
  uint32_t losses() const {
    return GetField<uint32_t>(VT_LOSSES, 0);
  }
  uint32_t simulations() const {
    return GetField<uint32_t>(VT_SIMULATIONS, 0);
  }
  const ::flatbuffers::Vector<uint32_t> *win_method_matrix() const {
    return GetPointer<const ::flatbuffers::Vector<uint32_t> *>(VT_WIN_METHOD_MATRIX);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_HAND_NAME) &&
           verifier.VerifyString(hand_name()) &&
           VerifyField<double>(verifier, VT_EQUITY, 8) &&
           VerifyField<uint32_t>(verifier, VT_WINS, 4) &&
           VerifyField<uint32_t>(verifier, VT_TIES, 4) &&
           VerifyField<uint32_t>(verifier, VT_LOSSES, 4) &&
           VerifyField<uint32_t>(verifier, VT_SIMULATIONS, 4) &&
           VerifyOffset(verifier, VT_WIN_METHOD_MATRIX) &&
           verifier.VerifyVector(win_method_matrix()) &&
           verifier.EndTable();
  }
};

struct HandEquityBuilder {
  typedef HandEquity Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_hand_name(::flatbuffers::Offset<::flatbuffers::String> hand_name) {
    fbb_.AddOffset(HandEquity::VT_HAND_NAME, hand_name);
  }
  void add_equity(double equity) {
    fbb_.AddElement<double>(HandEquity::VT_EQUITY, equity, 0.0);
  }
  void add_wins(uint32_t wins) {
    fbb_.AddElement<uint32_t>(HandEquity::VT_WINS, wins, 0);
  }
  void add_ties(uint32_t ties) {
    fbb_.AddElement<uint32_t>(HandEquity::VT_TIES, ties, 0);
  }
  void add_losses(uint32_t losses) {
    fbb_.AddElement<uint32_t>(HandEquity::VT_LOSSES, losses, 0);
  }
  void add_simulations(uint32_t simulations) {
    fbb_.AddElement<uint32_t>(HandEquity::VT_SIMULATIONS, simulations, 0);
  }
  void add_win_method_matrix(::flatbuffers::Offset<::flatbuffers::Vector<uint32_t>> win_method_matrix) {
    fbb_.AddOffset(HandEquity::VT_WIN_METHOD_MATRIX, win_method_matrix);
  }
  explicit HandEquityBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<HandEquity> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<HandEquity>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<HandEquity> CreateHandEquity(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> hand_name = 0,
    double equity = 0.0,
    uint32_t wins = 0,
    uint32_t ties = 0,
    uint32_t losses = 0,
    uint32_t simulations = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint32_t>> win_method_matrix = 0) {
  HandEquityBuilder builder_(_fbb);
  builder_.add_equity(equity);
  builder_.add_win_method_matrix(win_method_matrix);
  builder_.add_simulations(simulations);
  builder_.add_losses(losses);
  builder_.add_ties(ties);
  builder_.add_wins(wins);
  builder_.add_hand_name(hand_name);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<HandEquity> CreateHandEquityDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *hand_name = nullptr,
    double equity = 0.0,
    uint32_t wins = 0,
    uint32_t ties = 0,
    uint32_t losses = 0,
    uint32_t simulations = 0,
    const std::vector<uint32_t> *win_method_matrix = nullptr) {
  auto hand_name__ = hand_name ? _fbb.CreateString(hand_name) : 0;
  auto win_method_matrix__ = win_method_matrix ? _fbb.CreateVector<uint32_t>(*win_method_matrix) : 0;
  return Telemetry::CreateHandEquity(
      _fbb,
      hand_name__,
      equity,
      wins,
      ties,
      losses,
      simulations,
      win_method_matrix__);
}

struct TelemetryPacket FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef TelemetryPacketBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TIMESTAMP_NS = 4,
    VT_JOB_START_NS = 6,
    VT_HANDS_PROCESSED = 8,
    VT_CPU_PERCENT = 10,
    VT_MEMORY_RSS_KB = 12,
    VT_MEMORY_VMS_KB = 14,
    VT_THREAD_COUNT = 16,
    VT_CPU_CYCLES = 18,
    VT_STATUS = 20,
    VT_EQUITY_RESULTS = 22
  };
  uint64_t timestamp_ns() const {
    return GetField<uint64_t>(VT_TIMESTAMP_NS, 0);
  }
  uint64_t job_start_ns() const {
    return GetField<uint64_t>(VT_JOB_START_NS, 0);
  }
  uint64_t hands_processed() const {
    return GetField<uint64_t>(VT_HANDS_PROCESSED, 0);
  }
  double cpu_percent() const {
    return GetField<double>(VT_CPU_PERCENT, 0.0);
  }
  uint64_t memory_rss_kb() const {
    return GetField<uint64_t>(VT_MEMORY_RSS_KB, 0);
  }
  uint64_t memory_vms_kb() const {
    return GetField<uint64_t>(VT_MEMORY_VMS_KB, 0);
  }
  uint32_t thread_count() const {
    return GetField<uint32_t>(VT_THREAD_COUNT, 0);
  }
  uint64_t cpu_cycles() const {
    return GetField<uint64_t>(VT_CPU_CYCLES, 0);
  }
  uint8_t status() const {
    return GetField<uint8_t>(VT_STATUS, 0);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<Telemetry::HandEquity>> *equity_results() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<Telemetry::HandEquity>> *>(VT_EQUITY_RESULTS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_TIMESTAMP_NS, 8) &&
           VerifyField<uint64_t>(verifier, VT_JOB_START_NS, 8) &&
           VerifyField<uint64_t>(verifier, VT_HANDS_PROCESSED, 8) &&
           VerifyField<double>(verifier, VT_CPU_PERCENT, 8) &&
           VerifyField<uint64_t>(verifier, VT_MEMORY_RSS_KB, 8) &&
           VerifyField<uint64_t>(verifier, VT_MEMORY_VMS_KB, 8) &&
           VerifyField<uint32_t>(verifier, VT_THREAD_COUNT, 4) &&
           VerifyField<uint64_t>(verifier, VT_CPU_CYCLES, 8) &&
           VerifyField<uint8_t>(verifier, VT_STATUS, 1) &&
           VerifyOffset(verifier, VT_EQUITY_RESULTS) &&
           verifier.VerifyVector(equity_results()) &&
           verifier.VerifyVectorOfTables(equity_results()) &&
           verifier.EndTable();
  }
};

struct TelemetryPacketBuilder {
  typedef TelemetryPacket Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_timestamp_ns(uint64_t timestamp_ns) {
    fbb_.AddElement<uint64_t>(TelemetryPacket::VT_TIMESTAMP_NS, timestamp_ns, 0);
  }
  void add_job_start_ns(uint64_t job_start_ns) {
    fbb_.AddElement<uint64_t>(TelemetryPacket::VT_JOB_START_NS, job_start_ns, 0);
  }
  void add_hands_processed(uint64_t hands_processed) {
    fbb_.AddElement<uint64_t>(TelemetryPacket::VT_HANDS_PROCESSED, hands_processed, 0);
  }
  void add_cpu_percent(double cpu_percent) {
    fbb_.AddElement<double>(TelemetryPacket::VT_CPU_PERCENT, cpu_percent, 0.0);
  }
  void add_memory_rss_kb(uint64_t memory_rss_kb) {
    fbb_.AddElement<uint64_t>(TelemetryPacket::VT_MEMORY_RSS_KB, memory_rss_kb, 0);
  }
  void add_memory_vms_kb(uint64_t memory_vms_kb) {
    fbb_.AddElement<uint64_t>(TelemetryPacket::VT_MEMORY_VMS_KB, memory_vms_kb, 0);
  }
  void add_thread_count(uint32_t thread_count) {
    fbb_.AddElement<uint32_t>(TelemetryPacket::VT_THREAD_COUNT, thread_count, 0);
  }
  void add_cpu_cycles(uint64_t cpu_cycles) {
    fbb_.AddElement<uint64_t>(TelemetryPacket::VT_CPU_CYCLES, cpu_cycles, 0);
  }
  void add_status(uint8_t status) {
    fbb_.AddElement<uint8_t>(TelemetryPacket::VT_STATUS, status, 0);
  }
  void add_equity_results(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<Telemetry::HandEquity>>> equity_results) {
    fbb_.AddOffset(TelemetryPacket::VT_EQUITY_RESULTS, equity_results);
  }
  explicit TelemetryPacketBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<TelemetryPacket> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<TelemetryPacket>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<TelemetryPacket> CreateTelemetryPacket(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t timestamp_ns = 0,
    uint64_t job_start_ns = 0,
    uint64_t hands_processed = 0,
    double cpu_percent = 0.0,
    uint64_t memory_rss_kb = 0,
    uint64_t memory_vms_kb = 0,
    uint32_t thread_count = 0,
    uint64_t cpu_cycles = 0,
    uint8_t status = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<Telemetry::HandEquity>>> equity_results = 0) {
  TelemetryPacketBuilder builder_(_fbb);
  builder_.add_cpu_cycles(cpu_cycles);
  builder_.add_memory_vms_kb(memory_vms_kb);
  builder_.add_memory_rss_kb(memory_rss_kb);
  builder_.add_cpu_percent(cpu_percent);
  builder_.add_hands_processed(hands_processed);
  builder_.add_job_start_ns(job_start_ns);
  builder_.add_timestamp_ns(timestamp_ns);
  builder_.add_equity_results(equity_results);
  builder_.add_thread_count(thread_count);
  builder_.add_status(status);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<TelemetryPacket> CreateTelemetryPacketDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t timestamp_ns = 0,
    uint64_t job_start_ns = 0,
    uint64_t hands_processed = 0,
    double cpu_percent = 0.0,
    uint64_t memory_rss_kb = 0,
    uint64_t memory_vms_kb = 0,
    uint32_t thread_count = 0,
    uint64_t cpu_cycles = 0,
    uint8_t status = 0,
    const std::vector<::flatbuffers::Offset<Telemetry::HandEquity>> *equity_results = nullptr) {
  auto equity_results__ = equity_results ? _fbb.CreateVector<::flatbuffers::Offset<Telemetry::HandEquity>>(*equity_results) : 0;
  return Telemetry::CreateTelemetryPacket(
      _fbb,
      timestamp_ns,
      job_start_ns,
      hands_processed,
      cpu_percent,
      memory_rss_kb,
      memory_vms_kb,
      thread_count,
      cpu_cycles,
      status,
      equity_results__);
}

inline const Telemetry::TelemetryPacket *GetTelemetryPacket(const void *buf) {
  return ::flatbuffers::GetRoot<Telemetry::TelemetryPacket>(buf);
}

inline const Telemetry::TelemetryPacket *GetSizePrefixedTelemetryPacket(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<Telemetry::TelemetryPacket>(buf);
}

inline bool VerifyTelemetryPacketBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<Telemetry::TelemetryPacket>(nullptr);
}

inline bool VerifySizePrefixedTelemetryPacketBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<Telemetry::TelemetryPacket>(nullptr);
}

inline void FinishTelemetryPacketBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<Telemetry::TelemetryPacket> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedTelemetryPacketBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<Telemetry::TelemetryPacket> root) {
  fbb.FinishSizePrefixed(root);
}

}  // namespace Telemetry

#endif  // FLATBUFFERS_GENERATED_TELEMETRY_TELEMETRY_H_
